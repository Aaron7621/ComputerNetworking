## OSI

### 物理层

主要解决两台物理机之间的通信，通过**二进制比特流**的传输来实现，二进制数据表现为**电流电压上的强弱**，到达目的地再转化为**二进制机器码**。网卡、集线器工作在这一层。

### 数据链路层

**在不可靠的物理介质上提供可靠的传输**，接收来自物理层的位流形式的数据，并**封装成帧**，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，**使有差错的物理线路变为无差错的数据链路**。提供**物理地址寻址**功能。交换机工作在这一层。

### 网络层

将**网络地址翻译成对应的物理地址**，并决定如何将数据从发送方路由到接收方，通过路由选择算法为分组通过通信子网**选择最佳路径**。路由器工作在这一层。

### 传输层

传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是**在两个传输层实体之间有一条端到端的逻辑通信信道**。

### 会话层

建立会话：**身份验证，权限鉴定**等； 保持会话：对该会话进行维护，在会话维持期间两者可以随时使用这条会话传输局； 断开会话：当应用程序或应用层规定的超时时间到期后，OSI会话层才会释放这条会话。

### 表示层

对数据格式进行编译，对**收到或发出的数据根据应用层的特征进行处理**，如处理为文字、图片、音频、视频、文档等，还可以对压缩文件进行解压缩、对加密文件进行解密等。

### 应用层

提供应用层协议，如HTTP协议，FTP协议等等，方便应用程序之间进行通信。



## TCPIP

- 网络接口层
- 网际层
- 运输层
- 应用层

![tcpip_osi](D:\MyWorkBench\ComputerNetworking\picture\tcpip_osi.png)

![tcpip stack](D:\MyWorkBench\ComputerNetworking\picture\tcpip stack.png)







## TCP UDP区别

TCP作为**面向流**的协议，提供可靠的、**面向连接**的运输服务，并且提供点对点通信

UDP作为**面向报文**的协议，**不提供可靠交付**，并且**不需要连接**，不仅仅对点对点，也支持多播和广播

## 为什么TCP可靠

- TCP有三次握手建立连接，四次挥手关闭连接的机制

- 滑动窗口和拥塞控制算法。

- 最最关键的是还保留超时重传的机制。 

- 对于每份报文也存在校验，保证每份报文可靠性。

## 为什么UDP不可靠

UDP面向数据报无连接的

数据报发出去，就不保留数据备份了， 仅仅在IP数据报头部加入校验和复用

UDP没有服务器和客户端的概念

UDP报文过长的话是交给IP切成小段，如果某段报文废了就废了。

## TCP粘包

TCP是面向流协议，发送的单位是字节流，因此会将多个小尺寸数据被封装在一个tcp报文中发出去的可能性。 可以简单的理解成客户端调用了两次send，服务器端一个recv就把信息都读出来了。

粘包演示：https://zhuanlan.zhihu.com/p/77275039

粘包处理方法：固定发送信息长度，或在两个信息之间加入分隔符。

## TCP重传

- 超时重传：一段时间都没有收到ack，则触发超时重传。但是**超时重传时间（RTO）**估算比较复杂，是根据实验调出的公式，总的来说是围绕**包的往返时间（RTT）**估算的，但会根据网络情况动态变化。例如如果超时重传的包也超时了，则RTO需要加倍。因为说明此时网络情况不好
- 快速重传：不以时间驱动，以发送方收到的ack驱动。
  - 例如发一堆包，包1、3、4、5都到了，2丢包。则发送方连续收到3次同样的ack（2），则触发重传包2。
  - 问题在于发送端不知道应该重传一个2，还是2之后所有的包。
- Sack方法：接收方在发现丢包时，会把现在已经**接收到的、后面的**包的范围塞在ack的sack字段中，表明这些包已经接收到了。然后发送方在接收到3次同样的ack后，可以根据sack直到需要重传什么部分
- D-Sack：sack除了在接收方收不到正确的包，用于表达已经接收到的后面的包以外，在一些情况下也可以表达重复收到的包
  - ack丢包时：发送方超时重传，则接收方会受到重复的包，则在sack也放入重复的包的范围，这样发送方知道是ack丢包了
  - 发送方包延迟时：接收方会因为网络延迟收不到正确的包，发送重复的ack，导致发送方触发快速重传。最后延迟的包到，接收方会收到重复的，因此在sack中也塞入重复的包。发送发则知道是网络延迟的问题。

https://www.cnblogs.com/xiaolincoding/p/12732052.html



## TCP滑动窗口

https://www.cnblogs.com/xiaolincoding/p/12732052.html

滑动窗口是传输层进行流量控制的一种措施，接收方通过通告发 送方自己的窗口大小，从而控制发送方的发送速度，防止发送方发送速度过快而导致自己被淹没。

### 累计确认

这是和滑动窗口相关的第一个概念。发送方会根据窗口大小并行发送包，每个包都会有ACK从接收方传回。如果**ACK1丢包**，但是ACK10收到，那么发送方也不需要重传包1。因为ACK10代表10以前的所有包都收到。这就是累计确认

### 发送窗口

用4部分理解发送窗口：1. 已经发送并且已经收到ACK的；2. 已经发送但是还没收到ACK的；3. 还没发送但是还在窗口内，可以被发送的；4. 还没发送；但是暂时还不能发的。

![发送窗口](D:\MyWorkBench\ComputerNetworking\picture\发送窗口.jpg)



当发送方收到了相应#2中的ACK，则#1右边界右移，#3右边界右移。

#3是能够发但还未发的窗口，因此#3不为空，它的左边界也会不断右移。

**发送窗口实现：**4个变量

- SND.WND：发送窗口大小
- SND.UNA：（un acked）：#2左边界，即还没受到ACK的第一个包的位置
- SND.NXT：（next）：#3左边界，即马上可以发的第一个包的位置
- #4左边界：由SND.UNA+SND.WND计算得出

![发送窗口实现](D:\MyWorkBench\ComputerNetworking\picture\发送窗口实现.jpg)



也可以计算出#3大小，即可用窗口大小，如上图所示

### 接收窗口

- #1 + #2：已经成功接收并且确认接收的窗口
- #3：未收到数据且能接收的窗口，即可用的接收窗口
- #4：未收到数据且不可以接收数据的窗口

![](D:\MyWorkBench\ComputerNetworking\picture\接收窗口.jpg)

**接收窗口实现**

- RCV.WND：接收窗口大小
- RCV.NXT：#3左指针。即现在能接受的第一个包



*接收窗口和滑动窗口大小不是严格相等的。是约等于关系。因为可能接收端处理速度极快，而新的窗口大小通过接收方发送的TCP报文中的Windows字段告诉发送方，如果网络时延较大，则会产生不相等的现象*。



### 流量控制

首先，流量控制是建立在滑动窗口的机制上的。是利用动态调整滑动窗口大小的方式，**避免发送端发送过快，让接收端来不及接收（填满缓存）**

从前面滑动窗口的配置中，似乎感觉已经包含了“流量控制”的味道，即发送端接收到多少个ACK，可用窗口大小就左移多少。但是有一点很重要的区别是：**收到接收端的ACK不等于接收端已经处理好了这个包**，可能是：接收端确实接收了这个包，但还放在缓存里面没来得及处理。

所以需要接收端根据自己的处理能力，传给发送端此时接收端可用的接收窗口大小，作为发送端的新的发送窗口大小。



流量控制、调整发送窗口例子如下：

![](D:\MyWorkBench\ComputerNetworking\picture\流量控制1.jpg)

如上图，没有发生任何丢包，每次接收端都能顺利接收发送端所有数据并顺利回传ACK。但是接收端繁忙，每次能读取的数据都小于接收到的数据，甚至不读取，因此这些数据被屯在缓冲区，由OS管理。所以接收窗口变小，因此发送窗口也需要变小。



**禁止缓冲区和窗口大小同时调整**

当发送窗口在一定大小的时候，可以理解成是接收方对发送方的一种承诺，即发送方哪怕一瞬间把这个窗口用完、发完，接收方也总能缓存，其**缓冲区**也总是够的。

如果在收完这一波包，接收方因为资源紧张，需要缩减自己的缓冲区大小。则必须先告诉发送方要缩减窗户，在缩窗一段时间后，才能调整缓冲区的大小。

可以理解成缓冲区的大小至少应该等于窗口的大小，这样才能保证容纳发送方一次性发送的所有包。而如果一边缩窗，一边调整缓冲区，当缩窗的信息还没传递到发送方时，发送方按照原有的窗口发送包，则包到达接收方后则可能因为超出缓冲区范围导致丢包。

即一边缩窗一边调整缓冲区的操作，破坏了这种接收方对发送方在接收窗口上的承诺



**关闭窗口**

当接收方发送了0窗口，使发送方停止发送后。如果接收方希望发送方重新开始发送，则会发送窗口非0的通知。如果该通知丢包，则会使发送方一直等待发送，而接收方也一直没办法获得接收。产生死锁

因此，TCP 为每个连接设有一个持续定时器，**只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。**

如果持续计时器超时，就会发送**窗口探测 ( Window probe ) 报文**，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。

![窗口探测](D:\MyWorkBench\ComputerNetworking\picture\窗口探测.jpg)

窗口探测

- 如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；
- 如果接收窗口不是 0，那么死锁的局面就可以被打破了，发送方继续开始发送。

窗口探测的次数一般为 3 次，如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 `RST` 报文来中断连接。



**糊涂窗口综合症**

如果接收方太忙，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小（流量控制）。

如果接收方处理速度一直没有改善，这么下去下去，**接收方仅有几个字节的窗口，发送方也会义无反顾地发送这几个字节，这就是糊涂窗口综合症**。即：窗口太小，导致双方传输的数据很少。

因为 `TCP + IP` 头有 `40` 个字节，为了传输那几个字节的数据，要花上这么大的开销，不经济。

例子：

![糊涂窗口例子](D:\MyWorkBench\ComputerNetworking\picture\糊涂窗口例子.png)

因此：问题就是：窗口太小/数据太少。导致传输很浪费。

解决的根本是：在窗口较小/数据较少时，停止数据传输。

- 接收方：不通告小窗口给发送方。当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 0，也就阻止了发送方再发数据过来。
  等到接收方处理了一些数据后，窗口大小 >= MSS，或者接收方缓存空间有一半可以使用，再打开窗口让发送方发送数据。

- 发送方：避免发送小数据。使用Nagle 算法，该算法的思路是延时处理，它满足以下两个条件中的一条才可以发送数据：

  - 要等到窗口大小 >= `MSS` 或是 数据大小 >= `MSS`
  - 收到之前发送数据的 `ack` 回包

  只要不满足上面的条件，发送方则一直在屯数据。直到满足上面的条件。Nagle默认打开，当需要一下小数据交互的场景，则需要关闭。



## TCP拥塞控制

流量控制是为了避免发送方填满接收方的窗口，是发送方为接收方处理速度考虑做的限制。

拥塞控制是为了避免发送方的数据填满整个网络，是发送方为了**当前网络状况**考虑做的限制。因此拥塞控制**只需要考虑发送方**的发送速率即可。同样是用窗口做限制

### 拥塞窗口 cwnd

拥塞窗口也是一个窗口。当用上了拥塞控制+流量控制后，

**发送窗口swnd = min(拥塞窗口cwnd，接收窗口rwnd）**

这就是拥塞窗口的使用。总体来说

- 当网络没有拥塞，cwnd越来越大
- 否则，越来越小。

而检测网络是否有拥塞，就是通过**是否触发了重传**。

### 慢启动

核心：**当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。**

例子：

![](D:\MyWorkBench\ComputerNetworking\picture\慢启动.jpg)

慢启动过程中，cwnd**指数型增长**。

直到cwnd达到ssthresh（slow start threshold，慢启动门限）

- 当 `cwnd` < `ssthresh` 时，使用慢启动算法。
- 当 `cwnd` >= `ssthresh` 时，使用「拥塞避免算法」。

### 拥塞避免

进入拥塞阶段， **每当收到一个 ACK 时，cwnd 增加 1/cwnd。**总体来说，cwnd的增长呈线性（并非严格线性）

例子：

当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1

![](D:\MyWorkBench\ComputerNetworking\picture\拥塞避免.jpg)

### 超时重传恢复

当发生了超时重传（某ack一直没有到，直到超时）：

- ssthresh = cwnd / 2
- cwnd = 1

简单理解：重设慢启动门限，cwnd一夜回到解放前

![](D:\MyWorkBench\ComputerNetworking\picture\超时重传恢复.jpg)



### 快速重传恢复

当发生了快速重传（收到了三次同样的ack）

- ssthresh = cwnd/2
- cwnd = sshresh + 3。（也有的是直接就等于sshresh）

随后：

- 当继续收到重复的ack。cwnd ++
- 当收到了新的ack，cwnd = ssthresh。（相当于重新拥塞避免阶段开始）



*拥塞控制一览*

![](D:\MyWorkBench\ComputerNetworking\picture\拥塞控制overview.png)



