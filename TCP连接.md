https://xiaolincoding.com/network/3_tcp/tcp_interview.html

## TCP头部

![TCP头](.\picture\TCP头.png)

**序列号**：在建立连接时由计算机生成的*随机数*作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。**用来解决网络包*乱序*问题。**

**确认应答号**：指*下一次「期望」*收到的数据的序列号，发送端收到这个确认应答以后可以认为在**这个序号以前的数据都已经被正常接收**。用来解决**丢包**的问题。

**控制位：**

- *ACK*：该位为 `1` 时，「确认应答号」的字段变为有效，TCP 规定除了最初建立连接时的 `SYN` 包之外该位必须设置为 `1` ，表明大部分情况下ACK都可以随着数据传输，这样就省下了一步传输。（例如三次握手中的第二次就是）
- *RST*：该位为 `1` 时，表示 TCP 连接中出现异常必须**强制断开连接**。
- *SYN*：该位为 `1` 时，表示**希望建立连接**，并在其「序列号」的字段进行序列号初始值的设定。
- *FIN*：该位为 `1` 时，表示今后不会再有数据**发送**，希望断开连接（只意味着自己不再发，不意味着对面不再发以及自己不再收）。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 `FIN` 位为 1 的 TCP 段。



# 三次握手

![](picture\TCP三次握手.png)

- 一开始，客户端和服务端都处于 `CLOSE` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态



![](picture\第一次握手报文.png)

- 客户端会随机初始化序号`client_isn`，将此序号置于 TCP 首部的「序号」字段中，同时把 `SYN` 标志位置为 `1` ，表示 `SYN` 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 `SYN-SENT` 状态。



![](picture\第二次握手报文.png)

- 服务端收到客户端的 `SYN` 报文后，首先服务端也随机初始化自己的序号（`server_isn`），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 `client_isn + 1`, 接着把 `SYN` 和 `ACK` 标志位置为 `1`。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 `SYN-RCVD` 状态。
- *第二次握手其实相当于是第一次和第三次握手操作的合并*



![](picture\第三次握手报文.png)

- 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 `ACK` 标志位置为 `1` ，其次「确认应答号」字段填入 `server_isn + 1` ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 `ESTABLISHED` 状态。
- **第三次握手是可以携带数据的，前两次握手是不可以携带数据的**，这也是面试常问的题。



## 为什么是三次握手，不是两次，四次？

从直觉上看，以游戏开麦时候的确认作为类比，一个一对一的连接，需要双方都确认自己有发送和接收能力。

即：我要知道我说话对面能听到（发送能力），以及我能收到对面说的话（接受能力）。对面也是如此。

游戏开麦，接通时，此时不确定连接有没有问题，其实大家语言上的确认和TCP的三次握手一模一样：

- 我：喂，能听到吗？（测试我的发送能力）
- 对面：能听到。
  - 此时，我听到这句话说明我的发送和接收能力已经都OK了。即“对面能听到我，我也能听到对面”。
  - 此时对面因为听到了我说的话，也说明对面知道自己的接收能力ok了。但还不知道自己说的这句“能听到”是否我已经收到了。
- 对面：你能听到吗？（对面测试自己的发送能力）
- 我：能听到。（对面知道自己的发送能力也ok了）

结果

1. 我们都知道了我们说的话对面能听到，对面说的话我也能听到，因此连接开始，开始正常说话。
2. 显然如果用报文传输的话，2、3步可以合并在一个报文中



从技术上、具体细节上：

- 三次握手才可以阻止重复历史连接的初始化（主要原因）
- 三次握手才可以同步双方的初始序列号
- 三次握手才可以避免资源浪费

*原因一：避免历史连接*

简单来说，三次握手的**首要原因是为了防止旧的重复连接初始化造成混乱。**

例子：

![三次连接避免历史混乱图1](D:picture\三次连接避免历史混乱图1.png)

如果网络情况不好，发起方历史连接过了一段时间才到达。由于三次连接机制，被动方不会马上进入连接。而是发送被动方的ACK+SYN到发起方。

发起方收到了历史连接返回的ACK+SYN，根据自己的上下文知道这是旧的连接，因此发送RST中止历史连接。



假设两次握手，即被动方一收到SYN就马上进入连接状态：

![](picture\三次连接避免历史混乱图2.png)

上面这种场景下，「被动发起方」在向「主动发起方」发送数据前，并没有阻止掉历史连接，导致「被动发起方」建立了一个历史连接，又白白发送了数据，浪费了「被动发起方」的资源。



因此，**要解决这种现象，最好就是在「被动发起方」发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手**。

所以，**TCP 使用三次握手建立连接的最主要原因是*防止「历史连接」初始化了连接*。**有了三次握手，被动方在建立连接前就有一个中间状态来等待发起方确认（之所以是被动方需要有中间状态，是因为历史连接是发起方才知道的），历史的连接不会造成被动方资源的分配。



*原因二：同步双方初始序列号*

序列号是可靠传输的一个关键因素，它的作用：

- 接收方**识别重复**数据；
- 接收方可以根据序列号**按序接收**；
- 发送方标识发送出去的数据包中， 哪些已经被成功发送、对方收到的（通过 ACK 报文中的序列号）；

要完成序列号同步，就必须双方都有一次自己序列号的发送和对方关于自己序列号的ACK，即双方都必须各有一次一来一回。要完成这样，三次握手是最少的次数。

*序列号同步和直观理解三次握手的必要性是一个道理*



### 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？





